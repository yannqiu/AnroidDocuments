# 5、Android面试题库(java篇)

[Android面试大全（四大组件篇）](http://www.jianshu.com/p/9c0d9f561c8e)
[Android面试大全（性能优化篇）](http://www.jianshu.com/p/7c9df5b59a26)
[Android面试大全（异常处理篇）](http://www.jianshu.com/p/18fa6f1a3ed7)
[Android面试大全（开源框架篇）](http://www.jianshu.com/p/05ddce703d12)
[Android面试大全（网络篇）](http://www.jianshu.com/p/c07bec84d904)
[Android面试大全（java篇）](http://www.jianshu.com/p/dba49efea11a)

* * *

# java基础

*   java三大特性
    封装、继承、多态
*   多态实现原理
*   基本数据类型及占用的字节数
    8种

| 类型 | 包装类 | 所占位数（二进制） | 所占字节数 |
| --- | --- | --- | --- |
| byte(字节) | Byte | 8 | 1 |
| short（短整型） | Short | 16 | 2 |
| int（整型） | Integer | 32 | 4 |
| long（长整型） | Long | 64 | 8 |
| float（浮点型） | Float | 32 | 4 |
| double（双精度） | Double | 64 | 8 |
| char（字符型） | Character | 16 | 2 |
| boolean（布尔型） | Boolean | 1 |

*   switch支持什么类型
    jdk1.6以及之前版本是byte、char、short、int、枚举 五种
    jdk1.7时，又增加了String，所以相对于JDK1.7而言就是六种
*   String StringBuffer StringBuilder说明及区别
    *   字符串是否可改变
        String：String中的字符串是固定的，即常量
        StringBuffer StringBuilde都可改变字符串的长度等,通过.append()方法进行字符串的拼接
    *   线程安全方面：
        StringBuilder：线程非安全的
        StringBuffer：线程安全的
    *   执行速度比较
        StringBuilder>StringBuffer>String(少量数据其实区别不大)
    *   使用经验：
        1.操作少量的数据用 ：String
        2.单线程操作字符串缓冲区 下操作大量数据 ：StringBuilder
        3.多线程操作字符串缓冲区 下操作大量数据 ：StringBuffer（线程安全）
*   Java集合继承子类继承关系

    *   Collection
        *   List
            *   LinkedList
            *   ArrayList
            *   Vector
            *   Stack
    *   Map
        *   HashTable
        *   HashMap
        *   WeakHashMap
*   进程与线程区别
    一个程序至少有一个进程，一个进程至少有一个线程
    线程是比进程更小的划分单位，多线程程序的并发性高
    进程在执行的过程中拥有独立的内存单元，而线程是多个线程共享内存单元，从而提高程序运行效率
    两者执行过程有所区别。每个独立的线程有一个程序运行的入口、顺序执行序列以及程序的出口，但是线程是不能独立运行的，必须依附在应用程序中，有应用程序提供多个线程执行控制。
    线程是进程的一个实体，是CPU调度和分派的基本单元，是比进程更小的能独立运行的基本单位，线程自己不用有系统资源，只拥有在运行中必不可少的资源，它可与同属一个进程的其他线程共享进程所拥有的 全部资源
    一个线程可以创建和撤销另一个线程；统一进程中线程可以多个并发进行

*   final finally finalize都是干什么用的？有什么区别
    *   **final**
        final 是java中的关键字。如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。
        **final变量的初始化：**
        ①：在定义的时候初始化。
        ②：可以在初始化块中初始化，不可以在静态初始化块中初始化。
        ③：静态final变量可以在静态初始化块中初始化，不可以在初始化块中初始化。
        ④：还可以在类的构造器中初始化，但是静态final变量不可以。
    *   **finally**
        java中异常处理时，提供 finally 块来执行操作。在开发者使用finally的情况下，如果程序抛出一个异常，那么相匹配的 catch 模块会执行，然后程序就会进入 finally 块中，如果程序正常执行（未发生异常），在执行完程序后（try{}部分）同样会进入finally中，即无论程序是否异常，finally始终都会进入（开发者可以在此模块中做相应的操作，do everything what you want......）。有一种特殊情况可能不会进入，当程序还没执行完毕，强制结束程序进程。（这个是整个程序被终止了，和本身程序的执行顺序并没有什么关系）
    *   **finalize**
        方法名，java允许使用 finalize() 方法在垃圾收集器中将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。_finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的_。
*   java的四种引用？
    强引用、弱引用、软引用、虚引用
*   内部类、静态内部类、匿名内部类、局部内部类
*   ==与equals的区别
*   Java反射机制
*   Java注解相关
*   Java泛型
*   Java枚举
*   Java操作文件的基本API,RdomAccessFile
*   访问网络的基本API. Socket
*   Java异常有几种？什么是运行时异常，有什么特点？
*   接口与抽象类的区别
*   什么导致线程阻塞
*   ArrayMap对比HashMap
*   HashMap的实现原理
*   Java排序算法
*   接口的意义
    规范、扩展、回调
*   抽象类的意义
    为其子类提供一个公共的类型，封装子类中重复的内容，定义抽象方法。子类可有又不同的实现方法，但是定义是一致的
*   内部类的作用

    *   内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立
    *   在单个外围类中，可以让多个内部类以不同的方式实现同一个接口或者继承同一个类
    *   创建内部类对象的时刻并不依赖于外围内对象的创建
    *   内部类没有“is-a”关系，是一个独立的实体
    *   内部类提供了更好的封装，除了该外围类，其他类都不能访问
*   父类的静态方法能否被子类重写
    不能
    子类继承父类后，用相同的静态方法和非静态方法，这是非静态方法会覆盖父类中的非静态方法（即方法的重写），父类的该静态方法被隐藏（若对象是父类则调用该隐藏的方法），子类可继承父类的静态与非静态方法

* * *

_正在持续更新中……_


*   1、集合类以及集合框架；HashMap与HashTable实现原理，线程安全性，hash冲突及处理算法；ConcurrentHashMap；

*   2、进程和线程的区别；

*   3、Java的并发、多线程、线程模型；

*   4、什么是线程池，如何使用?

*   答：线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。

    5、数据一致性如何保证；Synchronized关键字，类锁，方法锁，重入锁；

    6、Java中实现多态的机制是什么；

*   7、如何将一个Java对象序列化到文件里；

    8、说说你对Java反射的理解；

*   答：Java 中的反射首先是能够获取到Java 中要反射类的字节码， 获取字节码有三种方法，
    1.Class.forName(className)

*   2.类名.class

*   3.this.getClass()。

*   然后将字节码中的方法，变量，构造函数等映射成相应的Method、Filed、Constructor 等类，这些类提供了丰富的方法可以被我们所使用。

*   4、同步的方法；多进程开发以及多进程应用场景；

    5、在Java中wait和seelp方法的不同；

*   答：最大的不同是在等待时wait 会释放锁，而sleep 一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行。

*   synchronized 和volatile 关键字的作用；

*   答：

*   1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

*   2）禁止进行指令重排序。

*   volatile 本质是在告诉jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
    1.volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的
    2.volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性
    3.volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
    4.volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化

*   6、服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达；

*   7、ThreadLocal原理，实现及如何保证Local属性；

    /8、String StringBuilder StringBuffer对比；

    9、你所知道的设计模式有哪些；

*   答：

*   Java 中一般认为有23 种设计模式，我们不需要所有的都会，但是其中常用的几种设计模式应该去掌握。下面列出了所有的设计模式。需要掌握的设计模式我单独列出来了，当然能掌握的越多越好。
    总体来说设计模式分为三大类：
    创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
    结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
    行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

*   10、Java如何调用c、c++语言；

*   11、接口与回调；回调的原理；写一个回调demo；

*   12、泛型原理，举例说明；解析与分派；

*   13、抽象类与接口的区别；应用场景；抽象类是否可以没有方法和属性；

*   14、静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？

*   15、修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法；

*   16、说说你对泛型的了解；

*   17、Java的异常体系；

*   18、如何控制某个方法允许并发访问线程的个数；

    19、动态代理的区别，什么场景使用；






##面试题： Java的值传递和引用传递问题

看过一些Java教材的话，对这句话应该不陌生：

**“在Java里面参数传递都是按值传递”**
这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递。
简单的说，基本类型是按值传递的，方法的实参是一个原值的复本。类对象是按对象的引用地址（内存地址）传递地址的值，那么在方法内对这个对象进行修改是会直接反应在原对象上的（或者说这两个引用指向同一内存地址）。不过要注意String这个类型，如下代码：

```
public static void main(String[] args) {
    String x = new String("goeasyway");
    change(x);
    System.out.println(x);
}

public static void change(String x) {
    x = "even";
}
```

可以自己思考一下会输出什么结果，为什么。String的对象是不可修改的，如果真正要达到改变字符串的效果，我们需要使用StringBuilder来替代String。



